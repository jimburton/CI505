# Haskell development environment

+ [Working with projects](#projects)
+ [Writing Haskell with style](#style)
+ [Editors for Haskell development](#editors)

<a name="projects"/>

## Working with projects

If you're working on a very small script or program that fits into one
module and has no external dependencies (i.e. you aren't importing
libraries that aren't part of the Haskell base language), you can get
along very well using the interpreter `ghci` to run and experiment
with the code and the compiler `ghc` to build an executable. For
anything bigger you need a *build tool*. This will automate
downloading of the dependencies, make sure everything is compiled in
the right order, make it easy to run a suite of tests and to package
your application for other users. There are two main ways of building
Haskell projects --
[`stack`](https://docs.haskellstack.org/en/stable/README/) and
[`cabal`](https://www.haskell.org/cabal/). We will be using `cabal`.

The recommended way to install `cabal` is by using
[GHCUp](https://www.haskell.org/ghcup/). If you used GHCUp to install
the compiler then you will have `cabal` installed already. You can
check this with the command `ghcup tui`. 

Run the command `cabal update`. This will download the latest list of
packages from the Hackage repository, which is where haskell
developers upload libraries and other software for distribution. The
default location for packages is `~/.cabal/bin`, where `~` is your
home directory.  On Linux it might be something like `/home/ab123`. To
run programs installed by `cabal` you need to add `~/.cabal/bin` to
your `PATH`. This is an environment variable containing a list of
locations in the file system that Bash will look in when you type a
command in to a terminal. On Linux you can check the current state of
`PATH` like this:

```bash
$ echo $PATH
```

You can add the `cabal` bin (short for "binary") directory to PATH by
editing the file `~/.bashrc`.  Add these lines to the bottom of the
file:

```bash
PATH=~/.cabal/bin:$PATH
export PATH
```

Then apply the changes:

```bash
$ source .bashrc
```

[The steps needed to add a location to the path on
Windows](https://helpdeskgeek.com/windows-10/add-windows-path-environment-variable/)
are a little different but no more complicated. Now you can start
building haskell projects. The basic idea is that each project lives
in its own directory and if the project is called `myproject` there
should be a config file called `myproject.cabal` at the top level. You
can generate a new project like this:

```bash
$ mkdir myproject
$ cd myproject
$ cabal init
$ ls
CHANGELOG.md  Main.hs  myproject.cabal  Setup.hs
```

Display the contents of the config file with `cat`. The details may
vary, but the contents will look something like this:

```bash
myproject$ cat myproject.cabal 
cabal-version:       >=1.10
-- Initial package description 'myproject.cabal' generated by 'cabal init'.
--   For further documentation, see http://haskell.org/cabal/users-guide/

name:                myproject
version:             0.1.0.0
-- synopsis:
-- description:
-- bug-reports:
-- license:
license-file:        LICENSE
author:              Jim Burton
maintainer:          j.burton@brighton.ac.uk
-- copyright:
-- category:
build-type:          Simple
extra-source-files:  CHANGELOG.md

executable myproject
  main-is:             Main.hs
  -- other-modules:
  -- other-extensions:
  build-depends:       base >=4.10 && <4.11
  -- hs-source-dirs:
  default-language:    Haskell2010

```

The upper block of text contains general information about the
project. The lower block, beginning with `executable ...`, tells
`cabal` to build an executable (i.e. a program) called `myproject`,
and that it can find the code in a file called `Main.hs`.

To get a better idea of the structure of a real Haskell project we
will look at two very simple projects as examples. The first is called
`change` -- it reads in a number from the user and calculates the
coins needed to make that amount. Clone the repository from github and
`cd` into the directory:

```
$ git clone https://github.com/jimburton/change
Cloning into 'change'...
...
$ cd change
```

Now you can use `cabal` to run the program:

```
change$ cabal run change
...
Enter a number and I'll count out the change
44
2 twenty pence pieces, 2 two pence pieces
Enter a number and I'll count out the change

```

Enter an empty line to stop using the program. List the contents of
the project folder:

```
change$ ls
cabal.project.local  ChangeLog.md   LICENSE    Setup.hs  TAGS
change.cabal         dist-newstyle  README.md  src       test

``` 

The main things to notice are the `src` folder, which is where the
code lives, and the config file `change.cabal`. Open the config file
and read the contents.

From the `cabal` file, you can see that the entry point for the
application is the file `src/Main.hs`. Open this file and read the
code. Don't worry if you don't understand all of it at this stage, but
look out for the `main` method -- this is the first function to run.
Note that most of the code is actually in the module called `Change`,
which is imported in the `Main` module. Open `Change.hs` and read this
file too.

The `test` folder contains tests for the project. Haskell testing will
be discussed later in the module. For now, use `cabal` to run the
tests, noting the names of the two test-suites given in
`change.cabal`.


Next, we will look at a project which is still very simple but
slightly more realistic because it uses some libraries. `mkpasswd` is
a program that generates new passwords of varying strength. Clone the
repository from github and `cd` into the top-level directory:

```
$ git clone https://github.com/jimburton/mkpasswd
Cloning into 'mkpasswd'...
...
$ cd mkpasswd
```

Take a look at the `cabal` config file for the new project,
`mkpasswd.cabal`. This is the block (or "stanza") that defines the
program to be built:

```
executable mkpasswd
  main-is:             Main.hs             
  other-modules:       MkPasswd.MkPasswd
  build-depends:       base
                     , random >=1.0 
  hs-source-dirs:      src
  default-language:    Haskell2010

```

`other-modules` is a list of all the modules in our program that are
used when it runs. `build-depends` is a list of all the external
libraries that it uses. In this case that is just `base` (i.e. the
Prelude functions) and `random`, used for making random
passwords. 

Below this stanza is a second one that defines a test suite. Because
there is more than one stanza, you need to tell `cabal` which you want
to run. Now run the program, followed by its tests:


```
$ cabal run mkpasswd
...
$ cabal run test-quickcheck
```

This program takes a variety of flags (or options) on the command line
that govern the kind of passwords that are generated. Pass the `--help` 
command to `MkPasswd` to lists all its options then experiment with 
producing a few different types of password:

```
$ cabal run mkpasswd --help
```

This is how you would run the program during development. `cabal` can
also install your programs permanently into `~/.cabal/bin`. Install
the program and run it:

```
$ cabal install
$ which mkpasswd
/home/jb259/.cabal/bin/mkpasswd
$ mkpasswd  -l 5 -e
vIt@15 [vitals] 
```

One more very useful thing `cabal` can do for you is to start the
interpreter, `ghci`, loading all the modules and dependencies that it
needs to run. This is done with the `repl` command. Run the program in
the REPL and call its `main` function:

```
$ cabal repl
...
*Main> main
K3MP'5
```

See the
[docs](https://www.haskell.org/cabal/users-guide/developing-packages.html)
for full information on `cabal`.

<a name="style"/>

## Writing Haskell with style

The way that you format and organise your code is important. It has an
 enormous effect on the readability and ease of maintaining the
 code. If you get used to using standard conventions then others will
 find it much easier to understand what you wrote, and you'll find it
 easier to read code written by others too. I recommend that everyone
 read and follow this [Haskell Style
 Guide](https://kowainik.github.io/posts/2019-02-06-style-guide).

You can also get suggestions on improving your code from the very
useful `hlint` tool. You can install it using `cabal`, read the hints
then fix them:

```
$ cabal install hlint
$ hlint src/
src/Main.hs:16:11-31: Warning: Use print
Found:
  putStrLn $ show coins
Perhaps:
  print coins

1 hint
```

<a name="editors"/>

## Editors for Haskell development

There are quite a few editors that support Haskell development,
ranging from ones which aim to be a full-on IDE to ones which just
provide a few helpful features such as syntax highlighting. You can do
everything you need to do with a basic editor and the terminal, and
it's important to know how to do that, but as your programs become
longer and solve more complex problems features like autocompletion,
refactoring, integration with **build tools** and **version control**
start to make a big difference to productivity.

There is a list of options which is kept up to date on the Haskell
wiki [here](https://wiki.haskell.org/IDEs).

I think the best option is to learn one of the "poweruser" editors,
[vim](https://www.vim.org/) or
[emacs](https://www.gnu.org/software/emacs/). I use emacs.

### Emacs for Haskell development

Once you get used to the quirky keybindings and terminology emacs is a
*very* powerful editor that has "modes" for every programming language
under the sun. The [Emacs for You](https://github.com/susam/emfy)
project provides an introduction to programming in Emacs and a small,
feature-rich configuration.

For integration between Emacs and `git`, see [`magit`](https://magit.vc/).

At a minimum, you want to install the Emacs "major" mode for Haskell,
`haskell-mode`.  `haskell-mode` is intentionally basic. It provides
syntax highlighting and a way to launch `ghci`. In my experience you
can already become very productive with this level of support but if
you want a modern IDE experience (autocompletion, highlighting errors,
jumping to the definition of functions, showing the docs for a
function or type when you hover over it, etc etc) you can install some
of the additional "minor" modes that run alongside `haskell-mode`.

Modifying Emacs is done by editing the config file, usually
`~/.emacs.d/init.el`. To install `haskell-mode` create that file if it
doesn't exist and add the following to it. (NB: If you have set up
"Emacs For You" the file will exist and already contain some of this
code.)

```elisp
;; sets up the emacs package manager and the use-package macro
(require 'package)
(add-to-list 'package-archives
	 '("melpa" . "https://melpa.org/packages/")
	 )
(package-initialize)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile
  (require 'use-package))
  
;; makes sure emacs gets your PATH right
(use-package exec-path-from-shell
	     :ensure t)
(exec-path-from-shell-initialize)

;; installs haskell-mode
(use-package haskell-mode
  :ensure t)
```

There are several ways to go about it but IMO the best option for an
IDE experience in emacs at the time of writing (2021) is
`lsp-mode`. This is an Emacs interface to the [Language Server
Protocol](https://github.com/Microsoft/language-server-protocol/),
which is a general framework for creating IDEs. Refactoring tasks like
renaming a function across an entire project don't work (yet) but
emacs is good at that sort of thing anyway. To get `lsp-mode` running
follow these steps:

+ Use GHCUp to install the Haskell Language Server.

+ Install the various minor modes that connect the Haskell Language
  Server to Emacs and provide autocompletion etc. The snippet below is
  how I'm doing it -- you could certainly make do with less. My
  `.emacs` file is pretty messy and diverges from best practice in
  several ways but if you're interested it's
  [here](https://github.com/jimburton/dot-files/blob/master/.emacs.d/init.el).
  
  ```elisp
  ;; which-key is useful for finding which keys are bound in different modes
  (use-package which-key
  :ensure t)
  (which-key-mode)
  ;; flycheck and flycheck-haskell are for checking errors on the fly
  (use-package flycheck
	  :ensure t
	  :defer 2
	  :diminish
	  :init (global-flycheck-mode)
	  :custom
	  (flycheck-display-errors-delay .3))
  (use-package flycheck-haskell
	  :ensure t)
  ;; the main lsp-mode
  (use-package lsp-mode
	  :init
	  :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
         (haskell-mode . lsp)
         (lsp-mode . lsp-enable-which-key-integration))
	 :commands lsp)
  ;; for showing hints etc from lsp-mode
  (use-package lsp-ui
	  :ensure t)
  ;; All of the lsp commands will begin `s-l`, i.e. by holding down the 
  ;; "super" key and l. The super key is the Windows key on MS keyboards.
  ;; Thanks to which-key you can type s-l then wait to get a list of all possible 
  ;; completions, which is a good way to find out what lsp-mode can do.
  (setq lsp-keymap-prefix "s-l")
  ;; Haskell integration with lsp-mode
  (use-package lsp-haskell
	  :ensure t)
  (add-hook 'haskell-mode-hook #'lsp)
  (add-hook 'haskell-literate-mode-hook #'lsp)
  ;; Autocompletion in Haskell files
  (use-package company-ghci
	  :ensure t)
  (push 'company-ghci company-backends)
  (add-hook 'haskell-mode-hook 'company-mode)
  (setq lsp-haskell-process-path-hie "haskell-language-server-wrapper")
  ;; A few handy keybindings. 
  (define-key lsp-command-map (kbd "i") 'lsp-ui-imenu)
  (define-key lsp-command-map (kbd "d") 'lsp-ui-doc-show)
  (define-key lsp-command-map (kbd "q") 'lsp-ui-doc-hide)
  (define-key lsp-command-map (kbd ".") 'completion-at-point)
  ```
  If all of this is working then you can now open a Haskell file in emacs and 
  do things like hold the pointer over any identifier to see its documentation, 
  right-click on an identifier to open a context menu enabling you to jump
  to the definition, open an `imenu` frame showing the structure
  of the current module with `s-l i`, and so on. 
