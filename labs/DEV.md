# Haskell development environment

+ [Working with projects](#projects)
+ [Writing Haskell with style](#style)
+ [Editors for Haskell development](#editors)

<a name="projects"/>

## Working with projects

If you're working on a very small script or program that fits into one
module and has no external dependencies (i.e. you aren't importing
libraries that aren't part of the Haskell base language), you can get
along very well using the interpreter `ghci` to run and experiment
with the code and the compiler `ghc` to build an executable. For
anything bigger you need a *build tool*. This will automate
downloading of the dependencies, make sure everything is compiled in
the right order, make it easy to run a suite of tests and to package
your application for other users. There are two main ways of building
Haskell projects --
[`stack`](https://docs.haskellstack.org/en/stable/README/) and
[`cabal`](https://www.haskell.org/cabal/). We will be using `cabal`.

`cabal` is installed as part of the Haskell platform but you should
make sure you have the latest version. Start by entering these commands
into a terminal:

```bash
$ cabal update

$ cabal install cabal-install
```

This will download the latest list of packages from the "Hackage"
repository (which is where haskell developers upload libraries and
other software for distribution) and install the latest version of
`cabal`. The default location for packages is
`~/.cabal/bin`, where `~` is your home directory.
On Linux it might be something like `/home/ab123`. To run 
programs installed by `cabal` (such as the
new version of it you just installed), you need to
add `~/.cabal/bin` to your `PATH`. This is an environment
variable containing a list of locations in the file system that Bash
will look in when you type a command in to a
terminal. On Linux you can check the current state of `PATH` like this:

```bash
$ echo $PATH
```

You can add the `cabal` bin (short for "binary") directory to PATH by
editing the file `~/.bashrc`.  Add these lines to the bottom of the
file:

```bash
PATH=~/.cabal/bin:$PATH
export PATH
```

Then apply the changes:

```bash
$ source .bashrc
```

Check that the changes were applied by echoing `PATH` again. The new
version of `cabal` should now be the first one that the system
encounters when you enter the command. Check this using the `which`
command, which reports the location of executables in your `PATH`. You
should see something like this:

```bash
$ which cabal
/home/ab123/.cabal/bin/cabal
```

([The steps needed to add a location to the path on Windows](https://helpdeskgeek.com/windows-10/add-windows-path-environment-variable/) 
are a little different but no more complicated.) Now you can start building 
haskell projects. The
basic idea is that each project lives in its own directory and if the
project is called `myproject` there should be a config file called `myproject.cabal`
at the top level. You can generate a new project like this:

```bash
$ mkdir myproject
$ cd myproject
$ cabal init
$ ls
CHANGELOG.md  Main.hs  myproject.cabal  Setup.hs
```

Display the contents of the config file with `cat`:

```bash
myproject$ cat myproject.cabal 
cabal-version:       >=1.10
-- Initial package description 'myproject.cabal' generated by 'cabal init'.
--   For further documentation, see http://haskell.org/cabal/users-guide/

name:                myproject
version:             0.1.0.0
-- synopsis:
-- description:
-- bug-reports:
-- license:
license-file:        LICENSE
author:              Jim Burton
maintainer:          j.burton@brighton.ac.uk
-- copyright:
-- category:
build-type:          Simple
extra-source-files:  CHANGELOG.md

executable myproject
  main-is:             Main.hs
  -- other-modules:
  -- other-extensions:
  build-depends:       base >=4.10 && <4.11
  -- hs-source-dirs:
  default-language:    Haskell2010

```

The upper block of text contains general information about the
project. The lower block, beginning with `executable ...`, tells
`cabal` to build an executable (i.e. a program) called `myproject`,
and that it can find the code in a file called `Main.hs`.

To get a better idea of the structure of a real Haskell project we
will look at two very simple projects as examples. The first is called
`change` -- it reads in a number from the user and calculates the
coins needed to make that amount. Clone the repository from github and
`cd` into the directory:

```
$ git clone https://github.com/jimburton/change
Cloning into 'change'...
...
$ cd change
```

Now you can use `cabal` to run the program:

```
change$ cabal run change
...
Enter a number and I'll count out the change
44
2 twenty pence pieces, 2 two pence pieces
Enter a number and I'll count out the change

```

Enter an empty line to stop using the program. List the contents of the
project folder:

```
change$ ls
cabal.project.local  ChangeLog.md   LICENSE    Setup.hs  TAGS
change.cabal         dist-newstyle  README.md  src       test

```
The main things to notice are the `src` folder, which is where the code
lives, and the config file `change.cabal`. Open the config file and read the contents. 

From the `cabal` file, you can see that the entry point for the
application is the file `src/Main.hs`. Open this file and read the
code. Don't worry if you don't understand all of it at this stage, but
look out for the `main` method -- this is the first function to run.
Note that most of the code is actually in the module called `Change`,
which is imported in the `Main` module. Open `Change.hs` and read this
file too.

The `test` folder contains tests for the project. Haskell testing will be 
discussed later in the module. For now, use `cabal` to run the tests,
noting the names of the two test-suites given in `change.cabal`.


Next, we will look at a project which is still very simple but
slightly more realistic because it uses some libraries. `mkpasswd` is
a program that generates new passwords of varying strength. Clone the
repository from github and `cd` into the top-level directory:

```
$ git clone https://github.com/jimburton/mkpasswd
Cloning into 'mkpasswd'...
...
$ cd mkpasswd
```

Take a look at the `cabal` config file for the new project,
`mkpasswd.cabal`. This is the block (or "stanza") that defines the program to be built:

```
executable mkpasswd
  main-is: Main.hs             
  other-modules:       MkPasswd.MkPasswd
                     , MkPasswd.Types
  build-depends:       base, random >=1.0 
  hs-source-dirs:      src
  default-language:    Haskell2010

```

`other-modules` is a list of all the modules in our program that are
used when it runs. `build-depends` is a list of all the external
libraries that it uses. In this case that is just `base` (i.e. the
Prelude functions) and `random`, used for making random
passwords. 

Below this stanza is a second one that defines a test suite. Because
there is more than one stanza, you need to tell `cabal` which you want
to run. Now run the program, followed by its tests:


```
$ cabal run mkpasswd
...
$ cabal run test-mkpasswd
```

This program takes a variety of flags (or options) on the command line that govern
the kind of passwords that are generated. If you want to pass flags to
a program that is being run by `cabal` you have to do so after two
dashes (`--`) so that `cabal` can distinguish between the arguments
intended for itself and those intended for *the program it is running*. Pass
the `--help` command to `MkPasswd` to lists all its options then
experiment with producing a few different types of password:

```
$ cabal run mkpasswd -- --help
```

This is how you would run the program during development. `cabal` can
also install your programs permanently into `~/.cabal/bin`. Install
the program and run it:

```
$ cabal install
$ which mkpasswd
/home/jb259/.cabal/bin/mkpasswd
$ mkpasswd  -l 5 -e
vIt@15 [vitals] 
```

One more very useful thing `cabal` can do for you is to start the interpreter, `ghci`,
loading all the modules and dependencies that it needs to run. This is done with the `repl`
command. Run the program in the REPL and call its `main` function:

```
$ cabal repl
...
*Main> main
K3MP'5
```

See the
[docs](https://www.haskell.org/cabal/users-guide/developing-packages.html)
for full information on `cabal`.

<a name="style"/>

## Writing Haskell with style

The way that you format and organise your code is important. It has an enormous effect on 
 the readability and ease of maintaining the code. If you get used to using standard conventions 
 then others will find it much easier to understand what you wrote, and you'll find it easier to 
 read code written by others too. I recommend that everyone read and follow 
 [Johan Tibell's Haskell Style Guide](https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md). 

You can also get suggestions on improving your code from the very useful `hlint` tool. You can 
install it using `cabal`, read the hints then fix them: 
```
$ cabal install hlint
$ hlint src/
src/Main.hs:16:11-31: Warning: Use print
Found:
  putStrLn $ show coins
Perhaps:
  print coins

1 hint
```

<a name="editors"/>

## Editors for Haskell development

There are quite a few editors that support Haskell development,
ranging from ones which aim to be a full-on IDE to ones which just
provide a few helpful features such as syntax highlighting. You can do
everything you need to do with a basic editor and the terminal, and
it's important to know how to do that, but as your programs become
longer and solve more complex problems features like autocompletion,
refactoring, integration with **build tools** and **version control**
start to make a big difference to productivity.

There is a list of options which is kept up to date on the Haskell
wiki [here](https://wiki.haskell.org/IDEs).

I think the best option is to learn one of the "poweruser" editors,
[vim](https://www.vim.org/) or [emacs](https://www.gnu.org/software/emacs/). I use emacs. 

### Emacs for Haskell development

Once you get used to the quirky keybindings and terminology emacs is a
*very* powerful editor that has "modes" for every programming language
under the sun. The [Emacs for You](https://github.com/susam/emfy)
project provides an introduction to programming in Emacs and a small,
feature-rich configuration.

For integration between Emacs and `git`, see [`magit`](https://magit.vc/).

At a minimum, you want to install the Emacs "major" mode for Haskell,
`haskell-mode`.  `haskell-mode` is intentionally basic. It provides
syntax highlighting and a way to launch `ghci`. To get something like
a modern IDE experience (autocompletion, highlighting errors, jumping
to the definition of functions, showing the docs for a function or
type when you hover over it, etc etc) you need to install several
additional "minor" modes that will run alongside `haskell-mode`. It
really isn't essential to use an IDE for Haskell development. You
can be very productive with just a powerful editor (Emacs +
`haskell-mode`) and `ghci`. Whether you feel that you need to bother
going further than that is up to you.

Modifying Emacs is done by editing the config file, usually
`~/.emacs`. To install `haskell-mode` add the following to your copy
of `.emacs`.

```elisp
;; sets up the emacs package manager and the use-package macro
(require 'package)
(add-to-list 'package-archives
	 '("melpa" . "https://melpa.org/packages/")
	 )
(package-initialize)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile
  (require 'use-package))
  
;; makes sure emacs gets your PATH right
(use-package exec-path-from-shell
	     :ensure t)
(exec-path-from-shell-initialize)

;; installs haskell-mode
(use-package haskell-mode
  :ensure t)
```

There are quite a few options for getting more bells and whistles than
`haskell-mode` provides. IMO the best at the time of writing (2021) is
`lsp-mode`. This is an Emacs interface to the [Language Server
Protocol](https://github.com/Microsoft/language-server-protocol/),
which is a general framework for creating IDEs. The Haskell Language
Server is a work in progress and if you are going to use it you should
periodically check the site below for major updates. Refactoring tasks
like renaming a function across an entire project don't work (yet)
but emacs is good at that sort of thing anyway. To get `lsp-mode`
running follow these steps:

+ Use [GHCUp](https://www.haskell.org/ghcup/) to install the Haskell Language
  Server.
+ Install the various minor modes that connect the Haskell Language
  Server to Emacs and provide autocompletion etc. The snippet below is
  how I'm doing it -- you could certainly make do with less. My `.emacs`
  file is very messy and diverges from best practice in many ways but
  if you're interested it's
  [here](https://github.com/jimburton/dot-files/blob/master/.emacs).
  
  ```elisp
  ;; which-key is useful for finding which keys are bound in different modes
  (use-package which-key
  :ensure t)
  (which-key-mode)
  ;; flycheck and flycheck-haskell are for checking errors on the fly
  (use-package flycheck
	  :ensure t
	  :defer 2
	  :diminish
	  :init (global-flycheck-mode)
	  :custom
	  (flycheck-display-errors-delay .3))
  (use-package flycheck-haskell
	  :ensure t)
  ;; the main lsp-mode
  (use-package lsp-mode
	  :init
	  :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
         (haskell-mode . lsp)
         (lsp-mode . lsp-enable-which-key-integration))
	 :commands lsp)
  ;; for showing hints etc from lsp-mode
  (use-package lsp-ui
	  :ensure t)
  ;; All of the lsp commands will begin `s-l`, i.e. by holding down the 
  ;; "super" key and l. The super key is the Windows key on MS keyboards.
  ;; Thanks to which-key you can type s-l then wait to get a list of all possible 
  ;; completions, which is a good way to find out what lsp-mode can do.
  (setq lsp-keymap-prefix "s-l")
  ;; Haskell integration with lsp-mode
  (use-package lsp-haskell
	  :ensure t)
  (add-hook 'haskell-mode-hook #'lsp)
  (add-hook 'haskell-literate-mode-hook #'lsp)
  ;; Autocompletion in Haskell files
  (use-package company-ghci
	  :ensure t)
  (push 'company-ghci company-backends)
  (add-hook 'haskell-mode-hook 'company-mode)
  ;; Turn off some noisy defaults
  (setq lsp-ui-sideline-show-code-actions nil
        lsp-ui-doc-show-with-cursor nil)
  ;; A few handy keybindings. 
  (define-key lsp-command-map (kbd "i") 'lsp-ui-imenu)
  (define-key lsp-command-map (kbd "d") 'lsp-ui-doc-show)
  (define-key lsp-command-map (kbd "q") 'lsp-ui-doc-hide)
  (define-key lsp-command-map (kbd ".") 'completion-at-point)
  ```
  If all of this is working then you can now open a Haskell file in emacs and 
  do things like hold the pointer over any identifier to see its documentation, 
  right-click on an identifier to open a context menu enabling you to jump
  to the definition, open an `imenu` frame showing the structure
  of the current module with `s-l i`, and so on. 
